// Generated by CoffeeScript 1.9.3
var Speaker, StreamPlayer, audioOptions, events, fs, lame, loadNextSong, request, self,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

Speaker = require('speaker');

lame = require('lame');

request = require('request');

events = require('events');

fs = require('fs');

audioOptions = {
  channels: 2,
  bitDepth: 16,
  mode: lame.STEREO
};

self = null;

StreamPlayer = (function(superClass) {
  extend(StreamPlayer, superClass);

  function StreamPlayer() {
    events.EventEmitter.call(this);
    self = this;
    this.queue = [];
    this.trackInfo = [];
    this.currentSong = null;
    this.playing = false;
    this.startTime = 0;
    this.speaker = null;
    this.decoder = null;
  }

  StreamPlayer.prototype.play = function() {
    if (this.currentSong !== null) {
      return this.resume();
    } else if (this.queue.length > 0 && !this.playing) {
      this.getStream(this.queue[0], this.playStream);
      this.playing = true;
      this.queue.shift();
      return this.currentSong = self.trackInfo.shift();
    } else if (this.playing) {
      return new Error('A song is already playing.');
    } else {
      return new Error('The queue is empty.');
    }
  };

  StreamPlayer.prototype.pause = function() {
    this.playing = false;
    this.speaker.removeAllListeners('close');
    return this.speaker.end();
  };

  StreamPlayer.prototype.resume = function() {
    this.speaker = new Speaker(audioOptions);
    this.decoder.pipe(this.speaker);
    this.playing = true;
    return this.speaker.once('close', function() {
      return loadNextSong();
    });
  };

  StreamPlayer.prototype.remove = function(id) {
    var index;
    index = this.trackInfo.map(function(info) {
      return info.id;
    }).indexOf(parseInt(id, 10));
    this.trackInfo.splice(index, 1);
    return this.queue.splice(index, 1);
  };

  StreamPlayer.prototype.add = function(url, track) {
    this.queue.push(url);
    this.trackInfo.push(track);
    return this.emit('song added');
  };

  StreamPlayer.prototype.nowPlaying = function() {
    if (this.playing) {
      return {
        track: this.currentSong,
        timestamp: this.startTime
      };
    } else {
      return new Error('No song is currently playing.');
    }
  };

  StreamPlayer.prototype.isPlaying = function() {
    return this.playing;
  };

  StreamPlayer.prototype.getQueue = function() {
    return this.trackInfo;
  };

  StreamPlayer.prototype.getStream = function(url, callback) {
    var stream;
    if (indexOf.call(url, 'http') < 0) {
      stream = fs.createReadStream(url);
      return callback(stream);
    } else {
      return request.get(url).on('response', function(res) {
        if (res.headers['content-type'] === 'audio/mpeg') {
          return callback(res);
        } else {
          self.emit('invalid url');
          return loadNextSong();
        }
      });
    }
  };

  StreamPlayer.prototype.playStream = function(stream) {
    self.decoder = new lame.Decoder();
    self.speaker = new Speaker(audioOptions);
    return stream.pipe(self.decoder).once('format', function() {
      self.decoder.pipe(self.speaker);
      self.startTime = Date.now();
      self.emit('play start');
      return self.speaker.once('close', function() {
        return loadNextSong();
      });
    });
  };

  return StreamPlayer;

})(events.EventEmitter);

loadNextSong = function() {
  self.currentSong = null;
  self.playing = false;
  self.emit('play end');
  return self.play();
};

module.exports = StreamPlayer;
